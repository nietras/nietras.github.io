---
layout: post
title: .NET 6 vs .NET 4.8 GC stats - ~64% shorter max GC pause times (due to 1 letter removed in runtime)
---

Recently I [tweeted about performance
improvements](https://twitter.com/nietras1/status/1462714385772724226?s=20) we
are seeing from migrating an industrial machine learning application (WPF) from
.NET Framework 4.8 to .NET 6 which got more likes than any blog post I've made
before. Additionally, Alex Yakunin's blog post on [.NET 6 vs .NET 5: up to 40%
speedup!](https://alexyakunin.medium.com/net-6-vs-net-5-up-to-40-speedup-ceca9112d298)
got some hacker news love, so I thought I'd give the crowd what it wants and
turn the tweets into a quick blog post. 😉

The application in question is used for inspection of products on a conveyor
belt and the sorting of these. It's connected to a dozen cameras and processes
about ~1GB/s worth of images with ~1000 inference/s. It has digital IO which
among others is used to control "latches" that sort out products. This has to be
performed with a certain precision, which means jitter caused by GC pauses is an
issue. Therefore, the application is highly optimized with special focus on
managed heap allocations utilizing pooling and recycling instances for all
numerical processing. Special care is also taken around UI given WPFs propensity
for doing lots of heap allocations. The remaining few allocations there are, are
small and ephemeral. A best case scenario for the .NET garbage collector, yet we
have always been seeing occasional longer pause times on .NET Framework 4.8. 

Recently, we switched from running inference on GPU to CPU and saw an increase
in these max pause times. At the same time .NET 6 was just about to release,
and we finally resolved the issues we had with porting to .NET Core/5+. We, therefore,
wondered if running on .NET 6 would provide any improvement to this? 
It certainly did, as can be seen below.

![.NET 6 vs .NET 4.8 GC stats]({{ site.baseurl }}/images/2021-11-dotnet-6-vs-4.8-gc-stats/net6-vs-net4.8-gc-stats-perfview-compare.png)

These are the **Memory Group -> GCStats** as shown in [PerfView](), which was
also used to record GC collection events from the application running both on
.NET Framework 4.8 and .NET 6 on Windows x64. In both cases for about a few days
in both cases, but not exactly the same duration. Max pause times drop from 13.5
ms to 4.9 ms, which translates to `(13.5-4.9)/13.5 ~= 64%` shorter max pause
times!

![.NET 6 vs .NET 4.8 GC events]({{ site.baseurl }}/images/2021-11-dotnet-6-vs-4.8-gc-stats/net4.8-vs-net6-gc-events.png)


![.NET 6 vs .NET 4.8 GC events zoom]({{ site.baseurl }}/images/2021-11-dotnet-6-vs-4.8-gc-stats/net4.8-vs-net6-gc-events-zoom.png)


https://github.com/dotnet/coreclr/pull/27578 "Change PING_JIT_TIMEOUT constant
from 10 milliseconds to 1 millisecond. This fixes the case where return address
hijacking doesn't work quickly, because the hijacked thread doesn't return (e.g.
because it's in a loop doing further calls). In this case we have to retry the
hijack, and changing the timeout constant makes this happen more quickly."

https://devblogs.microsoft.com/dotnet/suspending-and-resuming-threads-for-gc/
"suspension and resumption of threads is not really part of the GC. GC calls
functions to do the suspension and the resumption as a service provided in the
CLR. Other components in the CLR also use this service such as the debugger
implementation. But it’s true that suspending and resuming because of the GC is
the most significant usage of this service."

https://github.com/dotnet/coreclr/blob/775003a4c72f0acc37eab84628fcef541533ba4e/Documentation/botr/threading.md#hijacking
Thread hijacking in botr book. 


Just so you know, whatever you may think, your likes and retweets are truly
appreciated. I'm using my blog as a way to force myself to write more. Writing
and documenting can be a thankless task. You rarely get any appreciation when
you do make the effort, but always hear about when you didn't 😅, and you are
always busy. Writing in public gives an extra incentive and no matter how much
an introvert likes to be "above" external validation, it's very nice to know
someone out there appreciates whatever you are doing. So thank you. ❤️
